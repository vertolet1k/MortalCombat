/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */
package GUI;

import java.util.ArrayList;
import java.util.Random;
import javax.swing.JOptionPane;
import javax.swing.table.DefaultTableModel;
import playersInfo.*;

/**
 * Главный класс GUI для игры Mortal Combat.
 * Предоставляет графический интерфейс для взаимодействия с игрой,
 * включая боевую систему, инвентарь и таблицу рекордов.
 * 
 * @author vika
 * @version 1.0
 */
public class GUI extends javax.swing.JFrame {
    
    /** Игрок */
    private Player player;
    /** Противник */
    private Enemy enemy;
    /** Генератор случайных чисел */
    private Random random = new Random();
    /** Количество побежденных врагов */
    private int enemiesDefeated;
    /** Текущий уровень */
    private int currentLevel;
    /** Флаг боя с боссом */
    private boolean bossFight = false;
    /** Флаг использования креста возрождения */
    private boolean reviveCrossUsed = false;
    /** Минимальное количество очков для попадания в таблицу рекордов */
    private int minPoint = 0;
    /** Количество записей в таблице рекордов */
    private int recordsCount = 0;
    /** Общее количество локаций */
    private int totalLocations;
    /** Текущая локация */
    private int currentLocation;
    /** Количество врагов в текущей локации */
    private int enemiesInLocation;
    /** Количество побежденных врагов в текущей локации */
    private int enemiesDefeatedInLocation;
    /** Флаг активного ослабления противника */
    private boolean debuffActive = false;
    /** Количество ходов ослабления */
    private int debuffTurns = 0;
    /** Урон, нанесенный игроком в последний ход */
    private int lastPlayerDamage = 0;
    /** Последнее действие игрока */
    private String lastPlayerAction = "";
    /** Флаг регенерации босса */
    private boolean bossRegenerating = false;

    /**
     * Создает новый экземпляр GUI.
     * Инициализирует все компоненты интерфейса.
     */
    public GUI() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        gameWindow = new javax.swing.JFrame();
        fightLabel = new javax.swing.JLabel();
        player1 = new javax.swing.JLabel();
        player2 = new javax.swing.JLabel();
        healthEnemyProgressBar = new javax.swing.JProgressBar();
        healthMyProgressBar = new javax.swing.JProgressBar();
        AttackButton = new javax.swing.JButton();
        protectButton = new javax.swing.JButton();
        playerStats = new javax.swing.JLabel();
        enemyStats = new javax.swing.JLabel();
        jSeparator1 = new javax.swing.JSeparator();
        jScrollPane3 = new javax.swing.JScrollPane();
        logArea = new javax.swing.JTextArea();
        skipButton = new javax.swing.JButton();
        inventoryButton = new javax.swing.JButton();
        weakenButton = new javax.swing.JButton();
        gameOverDialog = new javax.swing.JDialog();
        gameOverLabel = new javax.swing.JLabel();
        gameResultsLabel = new javax.swing.JLabel();
        next2Button = new javax.swing.JButton();
        massegeAboutTop10Dialog = new javax.swing.JDialog();
        jLabel1 = new javax.swing.JLabel();
        showTableButton = new javax.swing.JButton();
        tableWinnersDialog = new javax.swing.JDialog();
        jScrollPane2 = new javax.swing.JScrollPane();
        winnersTable = new javax.swing.JTable();
        mainMenuButton = new javax.swing.JButton();
        inputNameDialog = new javax.swing.JDialog();
        inputNameLabel = new javax.swing.JLabel();
        next1Button = new javax.swing.JButton();
        inputNameField = new javax.swing.JTextField();
        startButton = new javax.swing.JButton();
        showResultsButton = new javax.swing.JButton();
        MortalCombatLabel = new javax.swing.JLabel();

        gameWindow.setTitle("gameWindow");
        gameWindow.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));

        fightLabel.setText("Fight");

        player1.setText("You");

        player2.setText("Enemy");

        AttackButton.setText("Attack");
        AttackButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                AttackButtonActionPerformed(evt);
            }
        });

        protectButton.setText("Protect");
        protectButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                protectButtonActionPerformed(evt);
            }
        });

        playerStats.setText("playerStats");

        enemyStats.setText("enemyStats");

        logArea.setEditable(false);
        logArea.setColumns(20);
        logArea.setRows(5);
        jScrollPane3.setViewportView(logArea);

        skipButton.setText("Skip");
        skipButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                skipButtonActionPerformed(evt);
            }
        });

        inventoryButton.setText("Inventory");
        inventoryButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                inventoryButtonActionPerformed(evt);
            }
        });

        weakenButton.setText("Weaken");
        weakenButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                weakenButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout gameWindowLayout = new javax.swing.GroupLayout(gameWindow.getContentPane());
        gameWindow.getContentPane().setLayout(gameWindowLayout);
        gameWindowLayout.setHorizontalGroup(
            gameWindowLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(gameWindowLayout.createSequentialGroup()
                .addGap(254, 254, 254)
                .addComponent(fightLabel)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .addGroup(gameWindowLayout.createSequentialGroup()
                .addGap(54, 54, 54)
                .addComponent(jSeparator1))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, gameWindowLayout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(inventoryButton)
                .addGap(18, 18, 18)
                .addComponent(weakenButton)
                .addGap(16, 16, 16)
                .addComponent(skipButton)
                .addGap(18, 18, 18)
                .addComponent(AttackButton)
                .addGap(18, 18, 18)
                .addComponent(protectButton)
                .addGap(9, 9, 9))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, gameWindowLayout.createSequentialGroup()
                .addGap(19, 19, 19)
                .addGroup(gameWindowLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(playerStats)
                    .addGroup(gameWindowLayout.createSequentialGroup()
                        .addComponent(healthMyProgressBar, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(player1))
                .addGap(18, 18, 18)
                .addGroup(gameWindowLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, gameWindowLayout.createSequentialGroup()
                        .addGroup(gameWindowLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(enemyStats)
                            .addComponent(healthEnemyProgressBar, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addContainerGap())
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, gameWindowLayout.createSequentialGroup()
                        .addComponent(player2)
                        .addGap(108, 108, 108))))
        );
        gameWindowLayout.setVerticalGroup(
            gameWindowLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, gameWindowLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(fightLabel)
                .addGap(37, 37, 37)
                .addGroup(gameWindowLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(player1)
                    .addComponent(player2))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(gameWindowLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(enemyStats)
                    .addComponent(playerStats))
                .addGroup(gameWindowLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(gameWindowLayout.createSequentialGroup()
                        .addGap(31, 31, 31)
                        .addGroup(gameWindowLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(healthMyProgressBar, javax.swing.GroupLayout.PREFERRED_SIZE, 27, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(healthEnemyProgressBar, javax.swing.GroupLayout.PREFERRED_SIZE, 27, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 59, Short.MAX_VALUE)
                        .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 27, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(33, 33, 33)
                        .addGroup(gameWindowLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(AttackButton)
                            .addComponent(protectButton)
                            .addComponent(skipButton)
                            .addComponent(inventoryButton)
                            .addComponent(weakenButton))
                        .addGap(14, 14, 14))
                    .addGroup(gameWindowLayout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
        );

        gameOverLabel.setText("Game over");

        gameResultsLabel.setText("gameResults");

        next2Button.setText("next");
        next2Button.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                next2ButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout gameOverDialogLayout = new javax.swing.GroupLayout(gameOverDialog.getContentPane());
        gameOverDialog.getContentPane().setLayout(gameOverDialogLayout);
        gameOverDialogLayout.setHorizontalGroup(
            gameOverDialogLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(gameOverDialogLayout.createSequentialGroup()
                .addGap(83, 83, 83)
                .addGroup(gameOverDialogLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(next2Button)
                    .addComponent(gameResultsLabel)
                    .addComponent(gameOverLabel))
                .addContainerGap(77, Short.MAX_VALUE))
        );
        gameOverDialogLayout.setVerticalGroup(
            gameOverDialogLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(gameOverDialogLayout.createSequentialGroup()
                .addGap(34, 34, 34)
                .addComponent(gameOverLabel)
                .addGap(27, 27, 27)
                .addComponent(gameResultsLabel)
                .addGap(29, 29, 29)
                .addComponent(next2Button)
                .addContainerGap(42, Short.MAX_VALUE))
        );

        jLabel1.setText("Congratulations! You are on top 10 players");

        showTableButton.setText("Show winners table");
        showTableButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                showTableButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout massegeAboutTop10DialogLayout = new javax.swing.GroupLayout(massegeAboutTop10Dialog.getContentPane());
        massegeAboutTop10Dialog.getContentPane().setLayout(massegeAboutTop10DialogLayout);
        massegeAboutTop10DialogLayout.setHorizontalGroup(
            massegeAboutTop10DialogLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(massegeAboutTop10DialogLayout.createSequentialGroup()
                .addGroup(massegeAboutTop10DialogLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(massegeAboutTop10DialogLayout.createSequentialGroup()
                        .addGap(53, 53, 53)
                        .addComponent(jLabel1))
                    .addGroup(massegeAboutTop10DialogLayout.createSequentialGroup()
                        .addGap(90, 90, 90)
                        .addComponent(showTableButton)))
                .addContainerGap(52, Short.MAX_VALUE))
        );
        massegeAboutTop10DialogLayout.setVerticalGroup(
            massegeAboutTop10DialogLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(massegeAboutTop10DialogLayout.createSequentialGroup()
                .addGap(39, 39, 39)
                .addComponent(jLabel1)
                .addGap(94, 94, 94)
                .addComponent(showTableButton)
                .addContainerGap(25, Short.MAX_VALUE))
        );

        winnersTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null}
            },
            new String [] {
                "Players name", "Points"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.Integer.class
            };
            boolean[] canEdit = new boolean [] {
                false, false
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        winnersTable.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        jScrollPane2.setViewportView(winnersTable);

        mainMenuButton.setText("Main menu");
        mainMenuButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mainMenuButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout tableWinnersDialogLayout = new javax.swing.GroupLayout(tableWinnersDialog.getContentPane());
        tableWinnersDialog.getContentPane().setLayout(tableWinnersDialogLayout);
        tableWinnersDialogLayout.setHorizontalGroup(
            tableWinnersDialogLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(tableWinnersDialogLayout.createSequentialGroup()
                .addGroup(tableWinnersDialogLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(tableWinnersDialogLayout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 375, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(tableWinnersDialogLayout.createSequentialGroup()
                        .addGap(150, 150, 150)
                        .addComponent(mainMenuButton)))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        tableWinnersDialogLayout.setVerticalGroup(
            tableWinnersDialogLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(tableWinnersDialogLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 275, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(mainMenuButton)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        inputNameLabel.setText("Input your name:");

        next1Button.setText("Next");
        next1Button.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                next1ButtonActionPerformed(evt);
            }
        });

        inputNameField.setColumns(10);

        javax.swing.GroupLayout inputNameDialogLayout = new javax.swing.GroupLayout(inputNameDialog.getContentPane());
        inputNameDialog.getContentPane().setLayout(inputNameDialogLayout);
        inputNameDialogLayout.setHorizontalGroup(
            inputNameDialogLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(inputNameDialogLayout.createSequentialGroup()
                .addGap(45, 45, 45)
                .addComponent(inputNameLabel)
                .addGap(28, 28, 28)
                .addComponent(inputNameField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(114, Short.MAX_VALUE))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, inputNameDialogLayout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(next1Button)
                .addGap(59, 59, 59))
        );
        inputNameDialogLayout.setVerticalGroup(
            inputNameDialogLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(inputNameDialogLayout.createSequentialGroup()
                .addGap(106, 106, 106)
                .addGroup(inputNameDialogLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(inputNameLabel)
                    .addComponent(inputNameField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 118, Short.MAX_VALUE)
                .addComponent(next1Button)
                .addGap(30, 30, 30))
        );

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("mainMenu");

        startButton.setText("Start game");
        startButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                startButtonActionPerformed(evt);
            }
        });

        showResultsButton.setText("Show results");
        showResultsButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                showResultsButtonActionPerformed(evt);
            }
        });

        MortalCombatLabel.setText("Mortal Combat");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(36, 36, 36)
                .addComponent(startButton)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 103, Short.MAX_VALUE)
                .addComponent(showResultsButton)
                .addGap(63, 63, 63))
            .addGroup(layout.createSequentialGroup()
                .addGap(160, 160, 160)
                .addComponent(MortalCombatLabel)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(46, 46, 46)
                .addComponent(MortalCombatLabel)
                .addGap(52, 52, 52)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(startButton)
                    .addComponent(showResultsButton))
                .addContainerGap(162, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void startButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_startButtonActionPerformed
        inputNameDialog.setVisible(true);
        inputNameDialog.setBounds(100, 100, 300, 300);
    }//GEN-LAST:event_startButtonActionPerformed

    private void showTableButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_showTableButtonActionPerformed
        tableWinnersDialog.setVisible(true);
        tableWinnersDialog.setBounds(100, 100, 400, 400);
        massegeAboutTop10Dialog.setVisible(false);
    }//GEN-LAST:event_showTableButtonActionPerformed

    private void showResultsButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_showResultsButtonActionPerformed
        tableWinnersDialog.setVisible(true);
        tableWinnersDialog.setBounds(100, 100, 500, 500);
    }//GEN-LAST:event_showResultsButtonActionPerformed

    private void next2ButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_next2ButtonActionPerformed
        if (player.getPoints() >= minPoint){
            massegeAboutTop10Dialog.setVisible(true);
            massegeAboutTop10Dialog.setBounds(100, 100, 580, 450);
        } else {
            tableWinnersDialog.setVisible(true);
            tableWinnersDialog.setBounds(100, 100, 500, 500);
        }
        gameOverDialog.setVisible(false);
    }//GEN-LAST:event_next2ButtonActionPerformed

    private void next1ButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_next1ButtonActionPerformed
        showGamePanel();
        inputNameDialog.setVisible(false);
    }//GEN-LAST:event_next1ButtonActionPerformed

    private void AttackButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_AttackButtonActionPerformed
        playerTurn("attack");
    }//GEN-LAST:event_AttackButtonActionPerformed

    private void protectButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_protectButtonActionPerformed
        playerTurn("defend");
    }//GEN-LAST:event_protectButtonActionPerformed

    private void skipButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_skipButtonActionPerformed
        playerTurn("skip");
    }//GEN-LAST:event_skipButtonActionPerformed

    private void inventoryButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_inventoryButtonActionPerformed
        showInventoryDialog();
    }//GEN-LAST:event_inventoryButtonActionPerformed

    private void weakenButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_weakenButtonActionPerformed
        playerTurn("weaken");
    }//GEN-LAST:event_weakenButtonActionPerformed

    private void mainMenuButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mainMenuButtonActionPerformed
        tableWinnersDialog.setVisible(false);
    }//GEN-LAST:event_mainMenuButtonActionPerformed
    
    /**
     * Показывает игровую панель и инициализирует новую игру.
     * Создает нового игрока с указанным именем и начинает первую локацию.
     */
    private void showGamePanel() {
        String name = inputNameField.getText();
        if (name == null || name.trim().isEmpty()) name = "Игрок";
        player = new Player(name);
        String locStr = JOptionPane.showInputDialog(this, "Сколько локаций пройти?", "Локации", JOptionPane.PLAIN_MESSAGE);
        try {
            totalLocations = Integer.parseInt(locStr);
        } catch (Exception e) {
            totalLocations = 1;
        }
        currentLocation = 1;
        startLocation();
        updateStats();
        gameWindow.setVisible(true);
        gameWindow.setBounds(10, 10, 800, 800);
    }
    
    /**
     * Начинает новую локацию.
     * Генерирует врагов для текущей локации и сбрасывает необходимые флаги.
     */
    private void startLocation() {
        currentLevel = currentLocation;
        enemiesInLocation = 2 + random.nextInt(4) + player.getLevel();
        enemiesDefeatedInLocation = 0;
        bossFight = false;
        reviveCrossUsed = false;
        enemy = generateEnemy();
        updateStats();
        logArea.setText("Локация " + currentLocation + " из " + totalLocations + ". Врагов: " + enemiesInLocation + "\n");
    }
    
    /**
     * Генерирует нового противника.
     * Если все обычные враги побеждены, генерирует босса.
     * 
     * @return новый экземпляр Enemy или Boss
     */
    private Enemy generateEnemy() {
        if (enemiesDefeatedInLocation >= enemiesInLocation) {
            bossFight = true;
            logArea.append("Бой с Боссом!\n");
            int bossHealth = player.getMaxHealth() * 3 / 2;
            int bossAttack = player.getAttack() + 10 + currentLevel * 2;
            return new Boss("Босс", bossHealth, bossAttack, 1);
        }
        bossFight = false;
        String[] types = {"Танк", "Маг", "Боец", "Солдат"};
        String type = types[random.nextInt(types.length)];
        int maxHealth = 60 + random.nextInt(61) + currentLevel * 10;
        int attack = 8 + random.nextInt(8) + currentLevel * 2;
        int behavior = getEnemyBehavior(type);
        return new Enemy(type, type, maxHealth, attack, behavior);
    }
    
    /**
     * Определяет поведение врага в зависимости от его типа.
     * 
     * @param type тип врага
     * @return код поведения (1-случайно атака/защита, 2-защита-атака-защита, 3-4 атаки)
     */
    private int getEnemyBehavior(String type) {
        int roll = random.nextInt(100);
        switch (type) {
            case "Танк":
                if (roll < 30) return 1;
                if (roll < 90) return 2;
                return 3;
            case "Маг":
                return (roll < 50) ? 1 : 3;
            case "Боец":
                if (roll < 25) return 1;
                if (roll < 35) return 2;
                return 3;
            case "Солдат":
                return (roll < 50) ? 1 : 2;
            default:
                return 1;
        }
    }
    
    /**
     * Обновляет статистику игрока и противника на экране.
     * Включает обновление полос здоровья и текстовых полей.
     */
    private void updateStats() {
        playerStats.setText(String.format("%s | Локация: %d/%d | Уровень: %d | Здоровье: %d/%d | Урон: %d | Опыт: %d/%d | Очки: %d",
                player.getName(), currentLocation, totalLocations, player.getLevel(), player.getHealth(), 
                player.getMaxHealth(), player.getAttack(), player.getExperience(), player.getExperienceToNextLevel(), 
                player.getPoints()));
        enemyStats.setText(String.format("%s | Здоровье: %d/%d | Урон: %d",
                enemy.getType(), enemy.getHealth(), enemy.getMaxHealth(), enemy.getAttack()));
        healthMyProgressBar.setMaximum(player.getMaxHealth());
        healthMyProgressBar.setValue(player.getHealth());
        healthMyProgressBar.setStringPainted(true);
        healthMyProgressBar.setString("Здоровье игрока");
        healthEnemyProgressBar.setMaximum(enemy.getMaxHealth());
        healthEnemyProgressBar.setValue(enemy.getHealth());
        healthEnemyProgressBar.setStringPainted(true);
        healthEnemyProgressBar.setString("Здоровье противника");
        if (debuffActive) {
            logArea.setText("Ослаблен (" + debuffTurns + ")");
        } 
    }
    
    /**
     * Обрабатывает ход игрока.
     * 
     * @param action действие игрока (attack, defend, skip, weaken)
     */
    private void playerTurn(String action) {
        if (player.getHealth() <= 0 || enemy.getHealth() <= 0) return;
        lastPlayerAction = action;
        int damage = player.getAttack();
        lastPlayerDamage = damage;
        switch (action) {
            case "attack":
                if (enemy.isDefending()) damage /= 2;
                if (debuffActive) damage = (int)(damage * 1.25);
                enemy.setHealth(enemy.getHealth() - damage);
                logArea.append("Вы атакуете противника и наносите " + damage + " урона!\n");
                break;
            case "defend":
                logArea.append("Вы встали в защиту!\n");
                player.setDefending(true);
                break;
            case "skip":
                logArea.append("Вы пропустили ход.\n");
                break;
            case "weaken":
                if (enemy.isDefending() && random.nextInt(100) < 75) {
                    debuffActive = true;
                    debuffTurns = player.getLevel();
                    logArea.setText("Ослаблен (" + debuffTurns + ")");
                    logArea.append("Вы ослабили противника на " + debuffTurns + " ходов!\n");
                } else if (!enemy.isDefending()) {
                    int extraDmg = (int)(player.getAttack() * 0.15);
                    enemy.setHealth(enemy.getHealth() - extraDmg);
                    logArea.append("Ослабление не удалось, но вы нанесли +" + extraDmg + " урона!\n");
                }
                break;
        }
        updateStats();
        if (enemy.getHealth() <= 0) { 
            if (bossFight) {
                logArea.append("Вы победили БОССА!\n");
                currentLocation++;
                if (currentLocation > totalLocations) {
                    logArea.append("Поздравляем! Вы прошли все уровни!\n");
                    if (recordsCount < 10){
                        addRecord();
                        recordsCount++;
                        if (minPoint > player.getPoints()) {
                            minPoint = player.getPoints();
                        }
                    } else if (recordsCount >= 10 && minPoint < player.getPoints()) {
                        winnersTable.setAutoCreateRowSorter(true);
                        ((DefaultTableModel)winnersTable.getModel()).removeRow(-1);
                        addRecord();
                    }
                    int points = player.getPoints();
                    gameWindow.setVisible(false);
                    gameOverDialog.setVisible(true);
                    gameOverDialog.setBounds(100, 100, 150, 150);
                    gameResultsLabel.setText("Победа! Очки: " + points);
                    return;
                } else {
                    logArea.append("Переход к следующей локации!\n");
                    startLocation();
                    return;
                }
            } else {
                logArea.append("Вы победили противника!\n");
                enemiesDefeatedInLocation++;
                tryDropItem();
                int exp = 30 + currentLevel * 10;
                int points = 100 + Math.max(0, player.getHealth());
                player.addExperience(exp);
                player.addPoints(points);
                logArea.append("Получено опыта: " + exp + ", очков: " + points + "\n");
                enemy = generateEnemy();
                updateStats();
                logArea.append(bossFight ? "Новый БОСС!\n" : "Новый противник!\n");
                debuffActive = false;
                debuffTurns = 0;
                return;
            }
        }
        enemyTurn();
    }
    
    /**
     * Обрабатывает ход противника.
     * Определяет действие противника и наносит урон игроку.
     */
    private void enemyTurn() {
        if (enemy.getHealth() <= 0) return;
        int move = getEnemyMove();
        if (bossFight && random.nextInt(100) <= 20) { // 20% шанс на регенерацию
            bossRegenerating = true;
            if (lastPlayerAction.equals("defend")) {
                int regen = lastPlayerDamage / 2;
                enemy.setHealth(enemy.getHealth() + regen);
                logArea.append("Босс регенерирует " + regen + " здоровья!\n");
            } else if (lastPlayerAction.equals("attack")) {
                enemy.setHealth(enemy.getHealth() - lastPlayerDamage * 2);
                logArea.append("Регенерация босса прервана! Босс получает двойной урон!\n");
            }
            bossRegenerating = false;
        } else if (move == 0) { // атака
            int damage = enemy.getAttack();
            if (player.isDefending()) {
                if (bossFight && random.nextInt(100) < 15) {
                    logArea.append("Босс пробил вашу защиту! Урон полный!\n");
                } else {
                    damage /= 2;
                    logArea.append("Противник атакует, но вы в защите! Урон снижен до " + damage + "!\n");
                }
            } else {
                logArea.append("Противник атакует и наносит вам " + damage + " урона!\n");
            }
            if (debuffActive) {
                damage = (int) (damage * 0.5);
                logArea.append("Ослабление: урон противника снижен!\n");
                debuffTurns--;
                logArea.setText("Ослаблен (" + debuffTurns + ")");
                if (debuffTurns <= 0) {
                    debuffActive = false;
                }
            }
            player.setHealth(player.getHealth() - damage);
        } else if (move == 1) { // защита
            logArea.append("Противник встал в защиту!\n");
            enemy.setDefending(true);
        } else if (move == 2) { // пропуск
            logArea.append("Противник пропустил ход.\n");
        }
        player.setDefending(false);
        enemy.setDefending(false);
        updateStats();
        if (player.getHealth() <= 0) {
            if (!reviveCrossUsed && player.getInventory().stream().anyMatch(i -> i.getType().equals("revive_cross"))) {
                reviveCrossUsed = true;
                player.setHealth(player.getMaxHealth() * 5 / 100);
                logArea.append("Крест возрождения спасает вас!\n");
                player.getInventory().removeIf(i -> i.getType().equals("revive_cross"));
                updateStats();
                return;
            }
            logArea.append("Вы проиграли!\n");
            if (recordsCount < 10){
                addRecord();
                recordsCount++;
                if (minPoint > player.getPoints()) {
                    minPoint = player.getPoints();
                }
            } else if (recordsCount >= 10 && minPoint < player.getPoints()) {
                winnersTable.setAutoCreateRowSorter(true);
                DefaultTableModel model = (DefaultTableModel) winnersTable.getModel();
                if (model.getRowCount() > 0) {
                    model.removeRow(model.getRowCount() - 1);
                }
                addRecord();
            }
            int points = player.getPoints();
            int result = JOptionPane.showConfirmDialog(this, "Вы проиграли! Начать заново?", "Поражение", JOptionPane.YES_NO_OPTION);
            if (result == JOptionPane.YES_OPTION) {
                showGamePanel();
            } else {
                gameWindow.setVisible(false);
                gameOverDialog.setVisible(true);
                gameOverDialog.setBounds(100, 100, 150, 150);
                gameResultsLabel.setText("gameResults: " + points);
            }
        }
    }
    
    /**
     * Определяет следующее действие противника.
     * 
     * @return код действия (0-атака, 1-защита, 2-пропуск)
     */
    private int getEnemyMove() {
        int behavior = enemy.getBehaviorType();
        switch (behavior) {
            case 1: // случайно атака/защита
                return random.nextBoolean() ? 0 : 1;
            case 2: // защита-атака-защита
                return (enemiesDefeated % 2 == 0) ? 1 : 0;
            case 3: // 4 атаки
                return 0;
            default:
                return random.nextInt(3);
        }
    }
    
    /**
     * Добавляет запись в таблицу рекордов.
     */
    private void addRecord() {
        DefaultTableModel model = (DefaultTableModel) winnersTable.getModel();
        String name = player.getName();
        int points = player.getPoints();
        model.addRow(new Object[] {name, points});
    }
    
    /**
     * Пытается выдать предмет игроку после победы над противником.
     * Шанс выпадения предмета зависит от типа предмета.
     */
    private void tryDropItem() {
        int roll = random.nextInt(100);
        if (roll < 25) {
            player.getInventory().add(new Item("Малое зелье", "small_potion", 25));
            logArea.append("Выпало малое зелье лечения!\n");
        } else if (roll < 40) {
            player.getInventory().add(new Item("Большое зелье", "big_potion", 50));
            logArea.append("Выпало большое зелье лечения!\n");
        } else if (roll < 45) {
            player.getInventory().add(new Item("Крест возрождения", "revive_cross", 5));
            logArea.append("Выпал крест возрождения!\n");
        }
    }
    
    /**
     * Показывает диалог инвентаря и позволяет использовать предметы.
     */
    private void showInventoryDialog() {
        ArrayList<Item> items = player.getInventory();
        if (items.isEmpty()) {
            JOptionPane.showMessageDialog(this, "Мешок пуст!");
            return;
        }
        String[] itemNames = items.stream().map(Item::getName).toArray(String[]::new);
        String selected = (String) JOptionPane.showInputDialog(this, "Выберите предмет:", "Мешок предметов",
                JOptionPane.PLAIN_MESSAGE, null, itemNames, itemNames[0]);
        if (selected != null) {
            Item item = items.stream().filter(i -> i.getName().equals(selected)).findFirst().orElse(null);
            if (item != null) {
                useItem(item);
                player.getInventory().remove(item);
                updateStats();
            }
        }
    }
    
    /**
     * Использует выбранный предмет.
     * 
     * @param item предмет для использования
     */
    private void useItem(Item item) {
        switch (item.getType()) {
            case "small_potion":
                player.setHealth(player.getHealth() + player.getMaxHealth() / 4);
                logArea.append("Использовано малое зелье лечения!\n");
                break;
            case "big_potion":
                player.setHealth(player.getHealth() + player.getMaxHealth() / 2);
                logArea.append("Использовано большое зелье лечения!\n");
                break;
            case "revive_cross":
                logArea.append("Крест возрождения будет использован автоматически при смерти!\n");
                break;
        }
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new GUI().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton AttackButton;
    private javax.swing.JLabel MortalCombatLabel;
    private javax.swing.JLabel enemyStats;
    private javax.swing.JLabel fightLabel;
    private javax.swing.JDialog gameOverDialog;
    private javax.swing.JLabel gameOverLabel;
    private javax.swing.JLabel gameResultsLabel;
    private javax.swing.JFrame gameWindow;
    private javax.swing.JProgressBar healthEnemyProgressBar;
    private javax.swing.JProgressBar healthMyProgressBar;
    private javax.swing.JDialog inputNameDialog;
    private javax.swing.JTextField inputNameField;
    private javax.swing.JLabel inputNameLabel;
    private javax.swing.JButton inventoryButton;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JSeparator jSeparator1;
    private javax.swing.JTextArea logArea;
    private javax.swing.JButton mainMenuButton;
    private javax.swing.JDialog massegeAboutTop10Dialog;
    private javax.swing.JButton next1Button;
    private javax.swing.JButton next2Button;
    private javax.swing.JLabel player1;
    private javax.swing.JLabel player2;
    private javax.swing.JLabel playerStats;
    private javax.swing.JButton protectButton;
    private javax.swing.JButton showResultsButton;
    private javax.swing.JButton showTableButton;
    private javax.swing.JButton skipButton;
    private javax.swing.JButton startButton;
    private javax.swing.JDialog tableWinnersDialog;
    private javax.swing.JButton weakenButton;
    private javax.swing.JTable winnersTable;
    // End of variables declaration//GEN-END:variables
}
